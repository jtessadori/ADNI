classdef traj < handle
    % January 2022, Jacopo Tessadori
    % The concept here is to compute some meaningful distance between
    % matrices for dynamic connectivity and apply some trajectory
    % classification in the resulting space, on ADNI data
    
    properties
        fileFolderPath;
        descrPath1;
        descrPath2;
        descrPath3;
        descrPath4;
        clinInfo;
        statePall;
        timeSeries;
        FC;
        subjID;
        lbls;
        nROIs;
        nSubjs;
        nDims;
        nStates;
        RS;
        feats;
        subjAge;
        subjSex;
        APOE4;
        stateFeats;
        binFeats;
        classNames;
    end
    
    methods
        function this=traj(FFP,DP1,DP2,DP3,DP4)
            % Constructor for traj class.
            % Required arguments are paths to data folder and to
            % description file
            this.fileFolderPath=FFP;
            this.descrPath1=DP1;
            this.descrPath2=DP2;
            this.descrPath3=DP3;
            this.descrPath4=DP4;
        end
        
        function loadRawData(this)
            %% Import database files (importfile and importfile2 are wizard-generated)
            DB1=importfile2(this.descrPath1, "ADNI3", [2, 1045]);
            DB2=importfile(this.descrPath2,[2 Inf]);

            % Generate correct labels and load patient data
            D=dir(this.fileFolderPath);
            fileNames=cat(1,{D.name});
            this.timeSeries=cell(0);
            this.lbls=cell(0);
            this.subjID=cell(0);
            this.subjAge=[];
            this.subjSex=[];
            this.APOE4=[];
            relIdxs={'ADAS11','MMSE','FAQ','RAVLT_immediate','RAVLT_learning','RAVLT_forgetting','CDRSB'};
            this.clinInfo=cell(length(relIdxs),1);
            for currSubj=1:height(DB1)
                patId=DB1.ID{currSubj};
                subjCond=DB1.ADNIMERGE(currSubj);
                if sum(contains(fileNames,patId))&&any(ismember({'CN','AD','MCI','EMCI','LMCI','SMC'},subjCond))
                    patIdx=fileNames{contains(fileNames,patId)};

                    % Recover entries for current subject
                    DB1curr=DB1(DB1.ID==patId,:);
                    DB2curr=DB2(DB2.PTID==patId,:);

                    % Recover classification in DB1
                    class1=DB1curr.ADNIMERGE;

                    % Recover first entry in ADNI3 for DB2
                    relEntry=find(DB2curr.COLPROT=="ADNI3",1,'first');

                    % Recover classification in first ADNI3 entry
                    class2=DB2curr.DX_bl(relEntry);

                    % Resolve conflicts
                    if isempty(class2)
                        subjCond=class1;
                    elseif isundefined(class2)
                        subjCond=class1;
                    elseif class2~=class1
                        subjCond=class2;
                    else 
                        subjCond=class2;
                    end

                    % Update time series, labels and additional clinical
                    % info
                    this.lbls=cat(1,this.lbls,subjCond);
                    subjData=load(fullfile(this.fileFolderPath,patIdx));
                    this.timeSeries=cat(1,this.timeSeries,{subjData.ms});
                    this.subjID=cat(1,this.subjID,DB1.ID(currSubj));
                    this.subjAge=cat(1,this.subjAge,DB1.AGE(currSubj));
                    this.subjSex=cat(1,this.subjSex,DB1.SEX(currSubj));
                    for currIdx=1:length(relIdxs)
                        if isempty(DB2curr)
                            this.clinInfo{currIdx}=cat(1,this.clinInfo{currIdx},nan);
                        else
                            this.clinInfo{currIdx}=cat(1,this.clinInfo{currIdx},DB2curr.(relIdxs{currIdx})(relEntry));
                        end
                    end
                    if isempty(DB2curr)
                        this.APOE4=cat(1,this.APOE4,nan);
                    else
                        this.APOE4=cat(1,this.APOE4,DB2curr.APOE4(relEntry));
                    end
                end
            end
        end

        function importATNdata(this)
            % Script for importing data from the following spreadsheet:
            %
            %    Workbook: descrPath3
            %    Worksheet: Foglio1
            %
            % Auto-generated by MATLAB on 09-Nov-2022 12:37:38

            %% Set up the Import Options and import the data
            opts = spreadsheetImportOptions("NumVariables", 17);

            % Specify sheet and range
            opts.Sheet = "Foglio1";
            opts.DataRange = "A2:Q492";

            % Specify column names and types
            opts.VariableNames = ["ID", "RID", "ADNIMERGE", "ACQUISITIONDATE", "AGE", "SEX", "ABETA", "TAU", "PTAU", "A_COMPOSITE_SUVR", "T_COMPOSITE_SUVR", "T_NORM_HIPPOCAMPUS_SUVR", "F_NORM_MEAN", "N_HIPPOCAMPUS_VOLUME", "N_AMYGDALA_VOLUME", "N_CTX_ENTORHINAL_VOLUME", "N_CTX_CAUDALMIDDLEFRONTAL_VOLUME"];
            opts.VariableTypes = ["string", "double", "categorical", "datetime", "double", "categorical", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double"];

            % Specify variable properties
            opts = setvaropts(opts, "ID", "WhitespaceRule", "preserve");
            opts = setvaropts(opts, ["ID", "ADNIMERGE", "SEX"], "EmptyFieldRule", "auto");
            opts = setvaropts(opts, "ACQUISITIONDATE", "InputFormat", "");

            % Import the data
            ADNIATNinfo = readtable(this.descrPath3, opts, "UseExcel", false);

            %% Add previous matched clinInfo (generated by me)
            scoresAddon=nan(size(this.clinInfo,1),11);
            for currSubj=1:size(ADNIATNinfo,1)
                relSubj=find(this.subjID==ADNIATNinfo.ID(currSubj));
                if ~isempty(relSubj)
                    scoresAddon(relSubj,:)=ADNIATNinfo{currSubj,7:end};
                end
            end
            scoresAddon(scoresAddon==-99)=nan;
            this.clinInfo=array2table(cat(2,this.clinInfo{:}),'VariableNames',{'ADAS11','MMSE','FAQ','RAVLT_immediate','RAVLT_learning','RAVLT_forgetting','CDRSB'});
            this.clinInfo=cat(2,this.clinInfo,array2table(scoresAddon,'VariableNames',ADNIATNinfo.Properties.VariableNames(7:end)));
            this.clinInfo=cat(2,this.clinInfo,array2table(this.subjAge,'VariableNames',{'AGE'}));
            this.clinInfo=cat(2,this.clinInfo,array2table(this.subjSex,'VariableNames',{'SEX'}));
        end

        function importFreesurferData(this)
            % Auto-generated by MATLAB on 09-Nov-2022 16:54:49

            %% Set up the Import Options and import the data
            opts = spreadsheetImportOptions("NumVariables", 44);

            % Specify sheet and range
            opts.Sheet = "((lh+rh)|2)|ICV";
            opts.DataRange = "A2:AR920";

            % Specify column names and types
            opts.VariableNames = ["PTID", "bankssts", "caudalanteriorcingulate", "caudalmiddlefrontal", "cuneus", "entorhinal", "fusiform", "inferiorparietal", "inferiortemporal", "isthmuscingulate", "lateraloccipital", "lateralorbitofrontal", "lingual", "medialorbitofrontal", "middletemporal", "parahippocampal", "paracentral", "parsopercularis", "parsorbitalis", "parstriangularis", "pericalcarine", "postcentral", "posteriorcingulate", "precentral", "precuneus", "rostralanteriorcingulate", "rostralmiddlefrontal", "superiorfrontal", "superiorparietal", "superiortemporal", "supramarginal", "frontalpole", "temporalpole", "transversetemporal", "insula", "CerebellumCortex", "Thalamus", "Caudate", "Putamen", "Pallidum", "Hippocampus", "Amygdala", "Accumbensarea", "EstimatedTotalIntraCranialVol"];
            opts.VariableTypes = ["string", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double"];

            % Specify variable properties
            opts = setvaropts(opts, "PTID", "WhitespaceRule", "preserve");
            opts = setvaropts(opts, "PTID", "EmptyFieldRule", "auto");

            % Import the data
            freesurferfeatures02112022S3 = readtable(this.descrPath4, opts, "UseExcel", false);

            %% Add previous to matched clinInfo (generated by me)
            scoresAddon=nan(size(this.clinInfo,1),size(freesurferfeatures02112022S3,2)-1);
            for currSubj=1:size(freesurferfeatures02112022S3,1)
                relSubj=find(this.subjID==freesurferfeatures02112022S3.PTID(currSubj));
                if ~isempty(relSubj)
                    scoresAddon(relSubj,:)=freesurferfeatures02112022S3{currSubj,2:end};
                end
            end
            this.clinInfo=cat(2,this.clinInfo,array2table(scoresAddon,'VariableNames',freesurferfeatures02112022S3.Properties.VariableNames(2:end)));
        end

        function HSall=recoverExpResults(this,expFolder)
            %% Load unsupervised sections of experiments
            relExps=dir([expFolder,'\22*.mat']);
            netOutCell=cell(length(relExps),1);
            RBFoutCell=cell(length(relExps),1);
            for currExp=1:length(relExps)
                load([expFolder,'\',relExps(currExp).name]); %#ok<LOAD> 
                clear netOutTrain
                clear RBFout
                blockID=zeros(size(this.lbls));
                blockID(1:25:end)=1;
                blockID=cumsum(blockID);
                for currBlock=1:max(blockID)
                    [netOutTrain(:,blockID==currBlock,:),RBFout(:,blockID==currBlock,:)]=predict(preTrndNet,dlarray(cat(4,this.feats{blockID==currBlock}),'STCB'),'Outputs',{'expLayer/out1','RBFlayer/out2'}); %#ok<AGROW>
                end
                netOutCell{currExp}=extractdata(netOutTrain);
                RBFoutCell{currExp}=extractdata(RBFout);
            end

            %% Recode HS clusters so that they have the same order (from more likely in
            % AD to more likely in HC) for all experiments

            nExps=size(relExps,1);
            cAllSorted=zeros(this.nStates,nExps);
            HSall=[];
            cDiffAllSorted=[];
            ordrAll=[];
            for currExp=1:nExps
                %     HS=zeros(1,size(T1{1},2),size(T1{1},3));
                %     [~,HS(:,:,size(T1{1},3))]=max(T1{currExp}(:,:,size(T1{1},3)));
                %     for currT=size(T1{currExp},3)-1:-1:1
                %         for currSubj=1:size(HS,2)
                %             HS(:,currSubj,currT)=T2{currExp}(HS(:,currSubj,currT+1),currSubj,currT+1);
                %         end
                %     end

                [~,HS]=max(netOutCell{currExp});
                HS=squeeze(HS);
                HS1=HS(this.lbls==1,:);
                HS2=HS(this.lbls==2,:);
                c1=histcounts(reshape(HS1,[],1),.5:this.nStates+.5,'Normalization','probability');
                c2=histcounts(reshape(HS2,[],1),.5:this.nStates+.5,'Normalization','probability');
                c=histcounts(reshape(HS,[],1),.5:this.nStates+.5,'Normalization','probability');
                cDiff=c1-c2;
                [~,stateOrdr]=sort(cDiff);
                ordrAll=cat(1,stateOrdr,ordrAll);
                HSnew=zeros(size(HS));
                for currState=1:this.nStates
                    HSnew(HS==stateOrdr(currState))=currState;
                end
                HSall=cat(3,HSall,HSnew);
                cAllSorted(:,currExp)=c(stateOrdr);
                cDiffAllSorted=cat(1,cDiffAllSorted,cDiff(stateOrdr));
            end

            %% Split subject state frequency in different cells, sorted by class
            this.statePall=cell(nExps,3);
            for currExp=1:nExps
                this.statePall{currExp,1}=squeeze(mean(HSall(:,:,currExp)==1,2));
                this.statePall{currExp,2}=squeeze(mean(HSall(:,:,currExp)==2,2));
                this.statePall{currExp,3}=squeeze(mean(HSall(:,:,currExp)==15,2));
            end
        end

        function recoverExpFeats(this)
            nExps=size(this.statePall,1);
            this.stateFeats=nan(size(this.clinInfo,1),nExps,3);
            this.binFeats=this.stateFeats;
            for currExp=1:nExps
                for currFeat=1:3
                    this.stateFeats(:,currExp,currFeat)=this.statePall{currExp,currFeat};
                    this.binFeats(:,currExp,currFeat)=this.stateFeats(:,currExp,currFeat)>.5;
                end
            end
        end
        
        function [baseLineBAcc,localClusteringBAcc,localFeatsFC,localFeatsClus]=baseLineTest(this)
            % Compute static FCs
            FCs=zeros(this.nSubjs,this.nROIs,this.nROIs);
            for currSubj=1:this.nSubjs
                FCs(currSubj,:,:)=corrcoef(normalize(this.timeSeries{currSubj}));
            end

            % Test each point for statistical difference
            FCs1=FCs(this.lbls==0,:);
            FCs2=FCs(this.lbls==1,:);
            P=zeros(this.nROIs^2,1);
            for currP=1:this.nROIs^2
                P(currP)=ranksum(FCs1(:,currP),FCs2(:,currP));
            end

            % Select features with P<.05 (and Bonferroni correction)
            relFeatsIdx=P*this.nROIs^2<.05;

            % Recover feats
            localFeatsFC=FCs(:,relFeatsIdx);

            % Train classifier
            c=histcounts(this.lbls,'Normalization','probability');
            if sum(relFeatsIdx)
                classSVM = fitcsvm(...
                    localFeatsFC, ...
                    this.lbls, ...
                    'KernelFunction', 'linear', ...
                    'PolynomialOrder', [], ...
                    'KernelScale', 'auto', ...
                    'BoxConstraint', 1, ...
                    'Standardize', true, ...
                    'Cost', [0 c(2); c(1) 0], ...
                    'ClassNames', [false; true], ...
                    'KFold',5);

                % Evaluate cross-val results
                addpath C:\Code\Common
                lblsEst=classSVM.kfoldPredict;
                baseLineBAcc=computeBAcc(this.lbls,lblsEst);
            else
                baseLineBAcc=.5;
            end

            % Compute local clustering coefficients. Consider two nodes
            % connected if correlation is higher that 3rd quartile of all
            % FCs
            connectivity=FCs>prctile(reshape(FCs,[],1),75);
            LCC=zeros(this.nSubjs,this.nROIs);
            for currSubj=1:this.nSubjs
                A=squeeze(connectivity(currSubj,:,:));
                for currNode=1:this.nROIs
                    nLinks=sum(A(A(currNode,:),A(currNode,:)),'all')/2;
                    nNodes=(sum(A(currNode,:)).*(sum(A(currNode,:))-1));
                    LCC(currSubj,currNode)=nLinks/nNodes;
                end
            end
               
            % Perform feature selection and evaluate cross-validated
            % classifier
            P=zeros(this.nROIs,1);
            for currP=1:this.nROIs
                P(currP)=ranksum(LCC(this.lbls==0,currP),LCC(this.lbls==1,currP));
            end
            relFeatsIdx=P*this.nROIs<.05;
            if sum(relFeatsIdx)
            localFeatsClus=LCC(:,relFeatsIdx);
            classSVM = fitcsvm(...
                localFeatsClus, ...
                this.lbls, ...
                'KernelFunction', 'linear', ...
                'PolynomialOrder', [], ...
                'KernelScale', 'auto', ...
                'BoxConstraint', 1, ...
                'Standardize', true, ...
                'Cost', [0 c(2); c(1) 0], ...
                'ClassNames', [false; true], ...
                'KFold',5);
            lblsEst=classSVM.kfoldPredict;
            localClusteringBAcc=computeBAcc(this.lbls,lblsEst);
            else
                localClusteringBAcc=.5;
            end
        end

        function untrndNet=designNet(this)
            % Define network
            this.nStates=15;
            seqLength=min(cellfun(@(x)size(x,2),this.feats));
            N=100;
            M1=16;
            M2=32;
            L1=20;
            L2=1;
            %% Create Layer Graph
            % Create the layer graph variable to contain the network layers.
            lgraph = layerGraph();
            %% Add Layer Branches
            % Add the branches of the network to the layer graph. Each branch is a linear
            % array of layers.

            tempLayers=[sequenceInputLayer([size(this.feats{1},1),1],"Name","featureinput","MinLength",seqLength)
                customConvLayer([1,L1],M1,1,"STCU","timeCorrConv",[1,1])
                leakyReluLayer(.5,"Name","relu1")
                customConvLayer([N.^2,L2],M2,M1,"STCU","spaceConv1",[1,1])
                leakyReluLayer(.5,"Name","relu2")
                fullyConnectedLayer(3,"Name","fc_1")
                batchNormalizationLayer("Name","bNorm")
                GRBFlayer(this.nStates,3,"RBFlayer")
                expectationLayer("expLayer")];
%             tempLayers(end-1) = setLearnRateFactor(tempLayers(end-1),"c",10);
%             tempLayers(end-1) = setLearnRateFactor(tempLayers(end-1),"sigma",10);

            lgraph = addLayers(lgraph,tempLayers);
            untrndNet=lgraph;
        end

        function preTrndNet=preTrainNet(this)
            addpath C:\Code\Common
            % Add some degree of noise to constant time series, then
            % multiply channels
            if isempty(this.feats)||size(this.feats{1},1)~=1e4
                for currSubj=1:length(this.lbls)
                    timeSeriesSD=std(this.timeSeries{currSubj});
                    this.timeSeries{currSubj}(:,timeSeriesSD==0)=randn(size(this.timeSeries{currSubj}(:,timeSeriesSD==0)))*1e-6;
                end
                this.feats=cellfun(@(x)normalize(x)',this.timeSeries,'UniformOutput',false);
                this.feats=cellfun(@(x)reshape(permute(x,[2,1,3]).*permute(x,[2,3,1]),size(x,2),[])',this.feats,'UniformOutput',false);

                % Compute acceptable time length, remove shorter sequences and
                % trim the rest
                seqLength=prctile(cellfun(@(x)size(x,2),this.feats),5);
                toBeRemoved=cellfun(@(x)size(x,2)<seqLength,this.feats);
                this.lbls(toBeRemoved)=[];
                this.feats(toBeRemoved)=[];
                this.timeSeries(toBeRemoved)=[];
                this.feats=cellfun(@(x)x(:,1:seqLength),this.feats,'UniformOutput',false);
            end

            %% Pre-train network on all available data
            % Initialie network
            untrndNet=this.designNet;
            batchSize=ceil(this.nSubjs/36);
            maxEpochs=15;
            iteration = 0;
            learnRate = 1e-3;
            gradDecay = 0.75;
            sqGradDecay = 0.95;
            dlnet = dlnetwork(untrndNet);
% 
%             % Set centers of GRBF function to meaningful points
%             rndOrdr=randperm(this.nSubjs);
%             relDataIdx=rndOrdr(1:batchSize);
%             tempTS=cat(4,this.feats{relDataIdx});
%             dlX=dlarray(tempTS,'STCB');
%             currNet=untrndNet;
%             bNorm=extractdata(predict(dlnetwork(untrndNet),dlX,'Outputs','bNorm'));
%             startPoints=squeeze(reshape(bNorm,1,size(bNorm,2),[]));
%             rndPoints=randperm(size(startPoints,2),this.nStates);
%             newLayers=currNet.Layers(6);
%             newLayers.c=startPoints(:,rndPoints);
%             currNet=replaceLayer(currNet,'RBFlayer',newLayers);
%             dlnet = dlnetwork(currNet);

            start=tic;
            for epoch = 1:maxEpochs
                % Shuffle data.
                rndOrdr=randperm(this.nSubjs);

                % Intialize useful stuff
                lastEntry=1;

                % Loop over mini-batches.
                while lastEntry+batchSize<=length(rndOrdr)
                    iteration = iteration + 1;

                    % Read mini-batch of data and add repetition-pad to
                    % ensure same-length sequences
                    relDataIdx=rndOrdr(lastEntry+1:lastEntry+batchSize);
                    tempTS=cat(4,this.feats{relDataIdx});
                    dlX=dlarray(tempTS,'STCB');
                    lastEntry=lastEntry+batchSize;

                    % Evaluate the model gradients, state, and loss using dlfeval and the
                    % modelGradients function and update the network state.
                    [grad,lossData,lgnd,state] = dlfeval(@traj.prototypeGradients,dlnet,dlX,[],1);
                    dlnet.State=state;
                    if ~exist('preTrainLog','var')
                        preTrainLog=lossData;
                    else
                        preTrainLog=cat(1,preTrainLog,lossData);
                    end

                    % Update the network parameters using the ADAM optimizer.
                    if ~exist('avg_g','var')
                        [dlnet,avg_g,avg_sqg] = adamupdate(dlnet,grad,[],[],1,learnRate,gradDecay,sqGradDecay);
                    else
                        [dlnet,avg_g,avg_sqg] = adamupdate(dlnet,grad,avg_g,avg_sqg,iteration,learnRate,gradDecay,sqGradDecay);
                    end

                    % Display the training progress.
                    if iteration>1
                        figure(1);
                        hold off;
                        D = duration(0,0,toc(start),'Format','hh:mm:ss');
                        h=plot(preTrainLog);
                        h(1).LineWidth=2;
                        xlabel("Iteration")
                        ylabel("Loss")
                        grid on
                        title("Epoch: " + epoch + ", Elapsed: " + string(D))
                        legend(lgnd,'Location','southwest');
                        drawnow
                    end
                end
            end

            % Save training graph
            DT=datetime('now','Format','yyMMdd_HHmmss');
            savefig(gcf,sprintf('%s_netTraining_fold.fig',DT));

            lgraph=dlnet.layerGraph;
%             newLayers=lgraph.Layers(6:7);
%             newLayers(1).c=lgraph.Layers(4).c;
%             newLayers(1).sigma=lgraph.Layers(4).sigma;
%             newLayers(2).baseTRs=lgraph.Layers(5).baseTRs;
%             lgraph=lgraph.replaceLayer('RBFlayer_2',newLayers(1));
%             lgraph=lgraph.replaceLayer('expLayer_2',newLayers(2));
            preTrndNet=dlnetwork(lgraph);

            % Save networks
            save(sprintf('%s_netTraining.mat',DT),'preTrndNet');
        end

        function [Ptable,Ntable,relScoreLog,relLblLog,p,N,PsexTable]=testClinInfo(this,relClasses,relScores,ageCorrect,relExps)
            nReps=1;
            if nargin<4
                ageCorrect='none';
            elseif strcmp(ageCorrect,'empirical')
                nReps=100;
            end
            nExps=size(this.statePall,1);
            if nargin<5
                relExps=1:nExps;
            end
            nExps=length(relExps);
            nScores=length(relScores);
            classSelection=zeros(size(this.binFeats,1),1);
            for currClass=1:length(relClasses)
                currClassID=find(contains(this.classNames,relClasses(currClass)));
                classSelection=classSelection+ismember(this.lbls,currClassID);
            end
            p=zeros(nExps,nScores,3,nReps);
            pSex=zeros(nExps,nScores,3,nReps);
            N=zeros(nExps,nScores,3,nReps);
            relScoreLog=cell(nExps,nScores,3,nReps);
            relLblLog=cell(nExps,nScores,3,nReps);
            for currExp=relExps
                for currScore=1:nScores
                    for currFeat=1:3
                        for currRep=1:nReps
                            relScore=this.clinInfo.(relScores{currScore});
                            relIdx=isfinite(relScore)&classSelection;
                            relScore=relScore(relIdx);
                            relLbls=logical(this.binFeats(relIdx,currExp,currFeat));
                            switch ageCorrect
                                case 'empirical'
                                    relAge=this.clinInfo.AGE(relIdx);
                                    relSex=this.clinInfo.SEX(relIdx)=='M';
                                    while ranksum(relAge(relLbls),relAge(~relLbls))<.2
                                        % Determine most numerous class
                                        dominantClass=mean(relLbls)>.5;
                                        % Remove a subject in most extreme
                                        % quartile of largest class
                                        largestMedian=median(relAge(relLbls==dominantClass))>median(relAge(relLbls~=dominantClass));
                                        if largestMedian
                                            removeCandidate=find((relLbls==dominantClass)&(relAge>quantile(relAge,.75)));
                                        else
                                            removeCandidate=find((relLbls==dominantClass)&(relAge<quantile(relAge,.25)));
                                        end
                                        removeTarget=removeCandidate(randperm(length(removeCandidate),1));
                                        relAge(removeTarget)=[];
                                        relLbls(removeTarget)=[];
                                        relScore(removeTarget)=[];
                                        relSex(removeTarget)=[];
                                        %                                     fprintf('%0.2f,%0.2f\n',median(relAge(relLbls)),median(relAge(~relLbls)));
                                    end
                                case 'linear'
                                    warning('off','curvefit:fit:iterationLimitReached');
                                    % Remove linear contribution of age
                                    % from current score
                                    % Set up fittype and options.
                                    ft = fittype( 'poly1' );
                                    opts = fitoptions( 'Method', 'LinearLeastSquares' );
                                    opts.Robust = 'LAR';

                                    % Fit model to data.
                                    relAge=this.clinInfo.AGE(relIdx);
                                    fitresult = fit( relAge, relScore, ft, opts );
                                    relScore=relScore-fitresult(relAge);
                                    warning('on','curvefit:fit:iterationLimitReached');
                                    [~,testP] = chi2gof(relScore);
                            end
                            if ~exist('testP','var')||(isfinite(testP)&&testP>0.05)
                                relScoreLog{currExp,currScore,currFeat,currRep}=relScore;
                                relLblLog{currExp,currScore,currFeat,currRep}=relLbls;
                                p(currExp,currScore,currFeat,currRep) = ranksum(relScore(relLbls),relScore(~relLbls));
                                [~, pSex(currExp,currScore,currFeat,currRep)] = fishertest(crosstab(relSex, relLbls));
                            else
                                p(currExp,currScore,currFeat,currRep) =nan;
                                pSex(currExp,currScore,currFeat,currRep) = nan;
                            end
                            N(currExp,currScore,currFeat,currRep)=length(relLbls);
                        end
                        fprintf('Exp: %d/%d, score: %d/%d, feat: %d/3\n',currExp,nExps,currScore,nScores,currFeat);
                    end
                end
            end
            Nmed=squeeze(median(N,[1,4]))';
            Pmed=squeeze(median(p,[1,4]))';
            PsexMed=squeeze(median(pSex,[1,4]))';
            Ptable=array2table(Pmed,"VariableNames",relScores,"RowNames",{'State 1','State 2','State 15'});
            Ntable=array2table(Nmed,"VariableNames",relScores,"RowNames",{'State 1','State 2','State 15'});
            PsexTable=array2table(PsexMed,"VariableNames",relScores,"RowNames",{'State 1','State 2','State 15'});
        end

%         function [Ptable,N]=testClinInfo(this,relClasses,relScores)
%             nExps=size(this.statePall,1);
%             nScores=length(relScores);
%             classSelection=zeros(size(this.binFeats,1),1);
%             for currClass=1:length(relClasses)
%                 currClassID=find(contains(this.classNames,relClasses(currClass)));
%                 classSelection=classSelection+ismember(this.lbls,currClassID);
%             end
%             p=zeros(nExps,nScores,3,nReps;);
%             for currExp=1:nExps
%                 for currScore=1:nScores
%                     for currFeat=1:3
%                         relScore=this.clinInfo.(relScores{currScore});
%                         relIdx=isfinite(relScore)&classSelection;
%                         relScore=relScore(relIdx);
%                         relLbls=logical(this.binFeats(relIdx,currExp,currFeat));
%                         p(currExp,currScore,currFeat) = ranksum(relScore(relLbls),relScore(~relLbls));
%                     end
%                 end
%             end
%             N=sum(relIdx);
%             Pmed=squeeze(median(p))';
%             Ptable=array2table(Pmed,"VariableNames",relScores,"RowNames",{'State 1','State 2','State 15'});
%         end

        function n=get.nROIs(this)
            n=size(this.timeSeries{1},2);
        end
        
        function n=get.nSubjs(this)
            n=length(this.lbls);
        end
                
        function nD=get.nDims(this)
            nD=size(this.feats{1},1);
        end
    end
    
    methods (Static)
        function [gradients,lossData,legendEntries,state,lhErrVec] = prototypeGradients(dlnet,dlX,lbls,computeGrad)
            % Recover network output
            shamOrdr=randperm(size(dlX,4));
            if nargin>2&&computeGrad
                [LH,state]=forward(dlnet,dlX,'Outputs',{'expLayer/out1'});
                [LHsham]=forward(dlnet,dlX(:,:,:,shamOrdr),'Outputs',{'expLayer/out1'});
            else
                [LH,state]=predict(dlnet,dlX,'Outputs',{'expLayer/out1'});
                [LHsham]=predict(dlnet,dlX(:,:,:,shamOrdr),'Outputs',{'expLayer/out1'});
            end

            % Relevant likelihoods should be as high as possible
            lhErrVec=-max(LH(:,:,end));
            lhErrAbs=mean(lhErrVec)/600;
            lhErrVecSham=-max(LHsham(:,:,end));
            lhErrAbsSham=mean(lhErrVecSham)/600;
            lhErrRel=lhErrAbs/lhErrAbsSham;

%             figure(2);
%             imagesc(squeeze(extractdata(stateRec)))
%             drawnow;

            loss=sqrt(lhErrAbs.^2+lhErrRel.^2);
            lossData=[extractdata(loss),extractdata(lhErrAbs),extractdata(lhErrRel)];
            legendEntries={'Loss','lhErrAbs','lhErrRel'};

            if nargin>2&&computeGrad
                gradients = dlgradient(loss,dlnet.Learnables);
                if any(cellfun(@(x)any(isnan(x),'all'),gradients.Value))
                    keyboard
                end
            else
                gradients=[];
            end

            if ~(sum(lbls)<=2)&&(any(isnan(lossData))||any(~isreal(lossData)))
                keyboard
            end
        end

        function [BAcc,logP]=HMMclassify(trainClus,trainPoints,trainLbls,testClus,testPoints,testLbls,modelOrder)
            % Use bayes theorem to estimate PDFs for each cluster.
            pB=mean(trainClus,[2,3]);
            pB=pB/sum(pB);

            classVals=unique(trainLbls);
            nClusters=size(trainClus,1);
            logP=zeros(length(testLbls),2);
            classP=log(histcounts(trainLbls,'Normalization','probability'));

            % Generate matrix form of feats and clusters, with 0 in missing
            % positions
            HMM=struct('TR',{},'prior',{},'states',{});
            for currClass=1:length(classVals)
                % Compute pA_B for test set
                trainPts=reshape(trainPoints(:,trainLbls==classVals(currClass),:),size(trainPoints,1),[]);
                testPts=reshape(testPoints,size(testPoints,1),[]);
                %                 modelSizes=4:2:maxModels;
                %                 AIC = zeros(1,length(modelSizes));
                %                 gm = cell(1,length(modelSizes));
                %                 for k = 1:length(modelSizes)
                %                     gm{k} = fitgmdist(trainPts',modelSizes(k),'RegularizationValue',0.01);%,'Replicates',5);
                %                     AIC(k)= gm{k}.AIC;
                %                 end
                %                 [~,bestModel]=min(AIC);
                %                 pB_A_test=squeeze(testClus);
                %                 pA_test=reshape(gm{bestModel}.pdf(testPts'),1,size(testPoints,2),size(testPoints,3));
                gm = fitgmdist(trainPts',modelOrder,'RegularizationValue',0.01);%,'Replicates',5);
                pB_A_test=squeeze(testClus);
                pA_test=reshape(gm.pdf(testPts'),1,size(testPoints,2),size(testPoints,3));
                testP=permute(pB_A_test.*pA_test./pB,[2,3,1]);

                HMM(currClass).states=1:nClusters;

                % Compute transmission probs and priors
                relClus=squeeze(trainClus(:,trainLbls==classVals(currClass),:));
                TR=squeeze(mean(permute(relClus(:,:,2:end),[1,4,2,3]).*permute(relClus(:,:,1:end-1),[4,1,2,3]),[3,4]));
                TR=TR./sum(TR);
                HMM(currClass).TR=TR;
                HMM(currClass).prior=mean(relClus,[2,3]);

                % Compute end-state log likelihoods and correct for
                % unbalanced datasets
                for currSubj2=1:length(testLbls)
                    relData=squeeze(testP(currSubj2,:,:));
                    [likelyPath,classLogP]=traj.viterbi(relData,HMM(currClass));
                    logP(currSubj2,currClass)=classLogP(likelyPath(end),end)+classP(currClass);
                end
            end

            % Perform classification
            addpath C:\Code\Common
            [~,lblsEst]=max(logP,[],2);
            lblsEst=lblsEst-1;
            BAcc=computeBAcc(testLbls,lblsEst);
            fprintf('BAcc: %0.2f\n\n',BAcc);
        end

        function [x,logP]=viterbi(dataPDF,HMM)
            nStates=length(HMM.prior);
            nObs=size(dataPDF,1);
            T1=zeros(nStates,nObs);
            T2=T1;
            for currState=1:nStates
                T1(currState,1)=log(HMM.prior(currState)*dataPDF(1,currState));
                T2(currState,1)=0;
            end
            for currT=2:nObs
                for currState=1:nStates
                    %                     currOut=T1(:,currT-1)+log(HMM.TR(currState,:)')+log(HMM.GM{currState}.pdf(obs(currT,:)));
                    currOut=T1(:,currT-1)+log(HMM.TR(:,currState))+log(dataPDF(currT,currState));
                    [T1(currState,currT),T2(currState,currT)]=max(currOut);
                end
            end
            [~,z(nObs)]=max(T1(:,end));
            x(nObs)=HMM.states(z(end));
            for currT=nObs:-1:2
                z(currT-1)=T2(z(currT),currT);
                x(currT-1)=HMM.states(z(currT-1));
            end
            logP=T1;
        end
    end
end